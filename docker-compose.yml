services:
  minio:
    container_name: minio
    image: minio/minio:latest
    command: ["minio", "server", "/data", "--console-address", ":${MINIO_CONSOLE_PORT}"]
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
      MINIO_CONSOLE_PORT: ${MINIO_CONSOLE_PORT}
      MINIO_PORT: ${MINIO_PORT}
    ports:
      - "${MINIO_PORT}:${MINIO_PORT}"
      - "${MINIO_CONSOLE_PORT}:${MINIO_CONSOLE_PORT}"
    expose:
      - ${MINIO_PORT}`
    volumes:
      - ./core/minio/data:/data
    networks:
      - entask
    labels:
      - "traefik.enable=false"
  
  # nats quorum
  nats-1:
    image: nats:2.11-alpine
    environment:
      NATS_USER: ${NATS_USER}
      NATS_PASSWORD: ${NATS_PASSWORD}
      NATS_TIMEOUT: ${NATS_TIMEOUT}
      NATS_HOST: ${NATS_HOST}
      NATS_CLIENT_PORT: ${NATS_CLIENT_PORT}
      NATS_CLUSTER_PORT: ${NATS_CLUSTER_PORT}
      NATS_CLUSTER_NAME: ${NATS_CLUSTER_NAME}
    volumes:
      - ./core/nats/server.conf:/etc/nats/nats.conf
      - ./core/nats/data/nats-1:/data
    command: ["-c", "/etc/nats/nats.conf", "--server_name", "nats-1"]
    ports:
      - "${NATS_CLIENT_PORT}:${NATS_CLIENT_PORT}"
      - "${NATS_CLUSTER_PORT}:${NATS_CLUSTER_PORT}"
      - "${NATS_MONITOR_PORT}:${NATS_MONITOR_PORT}"
    expose:
      - ${NATS_CLIENT_PORT}
      - ${NATS_CLUSTER_PORT}
      - ${NATS_MONITOR_PORT}
    networks:
      - entask
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:${NATS_MONITOR_PORT}/healthz"]
      interval: 90s
      timeout: 30s
      retries: 5
      start_period: 5s
    labels:
      - "traefik.enable=false"
      
  nats-2:
    image: nats:2.11-alpine
    environment:
      NATS_USER: ${NATS_USER}
      NATS_PASSWORD: ${NATS_PASSWORD}
      NATS_TIMEOUT: ${NATS_TIMEOUT}
      NATS_HOST: ${NATS_HOST}
      NATS_CLIENT_PORT: ${NATS_CLIENT_PORT}
      NATS_CLUSTER_PORT: ${NATS_CLUSTER_PORT}
      NATS_CLUSTER_NAME: ${NATS_CLUSTER_NAME}
    expose:
      - ${NATS_CLIENT_PORT}
      - ${NATS_CLUSTER_PORT}
      - ${NATS_MONITOR_PORT}
    volumes:
      - ./core/nats/server.conf:/etc/nats/nats.conf
      - ./core/nats/data/nats-2:/data
    command: ["-c", "/etc/nats/nats.conf", "--server_name", "nats-2"]
    networks:
      - entask
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:${NATS_MONITOR_PORT}/healthz"]
      interval: 90s
      timeout: 30s
      retries: 5
      start_period: 5s
    labels:
      - "traefik.enable=false"

  nats-3:
    image: nats:2.11-alpine
    environment:
      NATS_USER: ${NATS_USER}
      NATS_PASSWORD: ${NATS_PASSWORD}
      NATS_TIMEOUT: ${NATS_TIMEOUT}
      NATS_HOST: ${NATS_HOST}
      NATS_CLIENT_PORT: ${NATS_CLIENT_PORT}
      NATS_CLUSTER_PORT: ${NATS_CLUSTER_PORT}
      NATS_CLUSTER_NAME: ${NATS_CLUSTER_NAME}
    expose:
      - ${NATS_CLIENT_PORT}
      - ${NATS_CLUSTER_PORT}
      - ${NATS_MONITOR_PORT}
    volumes:
      - ./core/nats/server.conf:/etc/nats/nats.conf
      - ./core/nats/data/nats-3:/data
    command: ["-c", "/etc/nats/nats.conf", "--server_name", "nats-3"]
    networks:
      - entask
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:${NATS_MONITOR_PORT}/healthz"]
      interval: 90s
      timeout: 30s
      retries: 5
      start_period: 5s
    labels:
      - "traefik.enable=false"

  postgres:
    container_name: postgres
    image: postgres:alpine
    shm_size: 512mb
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_HOST_AUTH_METHOD: ${POSTGRES_HOST_AUTH_METHOD}
    volumes:
      - ./core/postgres/initdb.sql:/docker-entrypoint-initdb.d/init.sql
      - ./core/postgres/data:/var/lib/postgresql/data
    networks:
      - entask
    healthcheck:
      test:
        [
          "CMD",
          "pg_isready",
          "-U",
          "${POSTGRES_USER}",
          "-p",
          "${POSTGRES_PORT}",
        ]
      interval: 60s
      timeout: 15s
      retries: 5
      start_period: 5s
    labels:
      - "traefik.enable=false"
      
  pgadmin:
    container_name: pgadmin
    image: dpage/pgadmin4
    restart: unless-stopped
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${POSTGRES_PASSWORD}
    networks:
      - entask
    ports:
      - "5434:80"
    labels:
      - "traefik.enable=false"

  pgbouncer:
    container_name: pgbouncer
    image: edoburu/pgbouncer:latest
    restart: always
    environment:
      PGBOUNCER_PORT: ${PGBOUNCER_PORT}
      POSTGRESQL_HOST: ${POSTGRES_HOST}
      POSTGRESQL_PORT: ${POSTGRES_PORT}
      DB_USER: ${POSTGRES_USER}
      DB_PASSWORD: ${POSTGRES_PASSWORD}
      DB_HOST: ${POSTGRES_HOST}
      AUTH_TYPE: ${POSTGRES_HOST_AUTH_METHOD}
      MAX_CLIENT_CONN: ${PGBOUNCER_MAX_CLIENT_CONN}
      DEFAULT_POOL_SIZE: ${PGBOUNCER_DEFAULT_POOL_SIZE}
      POOL_MODE: ${PGBOUNCER_POOL_MODE}
      LISTEN_ADDR: ${PGBOUNCER_LISTEN_ADDR}
      LISTEN_PORT: ${PGBOUNCER_LISTEN_PORT}
    depends_on:
      - postgres
    networks:
      - entask
    labels:
      - "traefik.enable=false"

  flyway:
    container_name: flyway
    build:
      context: /core/flyway
      dockerfile: Dockerfile
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      POSTGRES_HOST: ${POSTGRES_HOST}
      POSTGRES_PORT: ${POSTGRES_PORT}
      POSTGRES_MIGRATIONS_USER: ${POSTGRES_MIGRATIONS_USER}
      POSTGRES_MIGRATIONS_PASSWORD: ${POSTGRES_MIGRATIONS_PASSWORD}
      AUTH_DB: ${AUTH_DB}
      GATEWAY_DB: ${GATEWAY_DB}
      CONVERSION_DB: ${CONVERSION_DB}
    volumes:
      - "./core/flyway/scripts:/flyway/sql/"
    networks:
      - entask
    labels:
      - "traefik.enable=false"

  redis:
    container_name: redis
    image: redis:alpine
    environment:
      REDIS_PORT: ${REDIS_PORT}
      REDIS_HOST: ${REDIS_HOST}
    ports:
      - "${REDIS_PORT}:${REDIS_PORT}"
    networks:
      - entask
    labels:
      - "traefik.enable=false"

  placement:
    container_name: dapr-placement
    image: daprio/dapr
    command: ["./placement", "-port", "50006"]
    ports:
      - "50006:50006"
    networks:
      - entask
    labels:
      - "traefik.enable=false"

  traefik:
    container_name: traefik
    image: traefik:latest
    ports:
      - target: 80
        published: 80
        protocol: tcp
        mode: host
      - target: 443
        published: 443
        protocol: tcp
        mode: host
      - target: 8080
        published: 8080
        protocol: tcp
        mode: host
    healthcheck:
      test: ["CMD", "traefik", "version"]
      interval: 60s
      timeout: 15s
      retries: 5
      start_period: 5s
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./gateway/traefik/traefik.yml:/etc/traefik/traefik.yml
    networks:
      - entask   
  
  version-service:
    container_name: service-version
    build:
      context: ./services/version-api
      dockerfile: Dockerfile
    environment:
      VERSION_SERVICE_PORT: ${VERSION_SERVICE_PORT}
      AUTH_SERVICE_PORT: ${AUTH_SERVICE_PORT}
    networks:
      - entask
    volumes:
      - ./services/version-api:/services/version-api
    healthcheck:
      test:
        [
          "CMD",
          "curl",
          "--fail",
          "http://localhost:${VERSION_SERVICE_PORT}/api/version",
        ]
      interval: 60s
      timeout: 15s
      retries: 5
      start_period: 5s
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.version-service.loadbalancer.server.port=${VERSION_SERVICE_PORT}"
      - "traefik.http.routers.version.rule=PathRegexp(`/api/version(.*?)`)"
      - "traefik.http.routers.version.service=version-service"
      
  auth-service:
    container_name: service-auth
    build:
      context: ./services/auth
      dockerfile: Dockerfile
    environment:
      SERVICE_GROUP: ${AUTH_SERVICE_GROUP}
      AUTH_API_VERSION: ${AUTH_API_VERSION}
      AUTH_SERVICE_PORT: ${AUTH_SERVICE_PORT}
      AUTH_REDIS_HOST: ${REDIS_HOST}
      AUTH_REDIS_PORT: ${REDIS_PORT}
      FRONTEND_HOST: ${FRONTEND_HOST}
      FRONTEND_PORT: ${FRONTEND_PORT}
      CLIENT_SECRET_FILE: ${CLIENT_SECRET_FILE}
      AUTH_DB_USER: ${AUTH_DB_USER}
      AUTH_DB_PASSWORD: ${AUTH_DB_PASSWORD}
      AUTH_DB: ${AUTH_DB}
      AUTH_DB_HOST: ${AUTH_DB_HOST}
      AUTH_DB_PORT: ${AUTH_DB_PORT}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY}
      JWT_REFRESH_KEY: ${JWT_REFRESH_KEY}
      JWT_OIDC_KEY: ${JWT_OIDC_KEY}
      JWT_ALGORITHM: ${JWT_ALGORITHM}
      BCRYPT_EFF: ${BCRYPT_EFF}
      TRAEFIK_USES_HTTP: ${TRAEFIK_USES_HTTP}
      TRAEFIK_HTTP_PORT: ${TRAEFIK_HTTP_PORT}
      TRAEFIK_HTTPS_PORT: ${TRAEFIK_HTTPS_PORT}
    networks:
      - entask
    volumes:
      - ./services/auth:/services/auth
    healthcheck:
      test:
        [
          "CMD",
          "curl",
          "--fail",
          "http://localhost:${AUTH_SERVICE_PORT}/api/auth/health",
        ]
      interval: 60s
      timeout: 15s
      retries: 5
      start_period: 5s
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.auth-service.loadbalancer.server.port=${AUTH_SERVICE_PORT}"
      - "traefik.http.routers.auth.rule=PathRegexp(`/api/auth(.*?)`)"
      - "traefik.http.routers.auth.service=auth-service"
    develop:
      watch:
        - action: sync+restart
          path: ./services/auth
          target: /services/auth
          
  file-service:
    container_name: service-file
    build: 
      context: ./services/file
      dockerfile: Dockerfile
    environment:
      FILE_SERVICE_PORT: ${FILE_SERVICE_PORT}
      S3_HOST: ${S3_HOST}
      S3_PORT: ${S3_PORT}
      S3_ACCESS_KEY: ${MINIO_ROOT_USER}
      S3_SECRET_KEY: ${MINIO_ROOT_PASSWORD}
      S3_BUCKET_UPLOADS: ${S3_BUCKET_UPLOADS}
      S3_BUCKET_CONVERSIONS: ${S3_BUCKET_CONVERSIONS}
      AUTH_SERVICE_HOST: ${AUTH_SERVICE_HOST}
      AUTH_SERVICE_PORT: ${AUTH_SERVICE_PORT}
    develop:
      watch:
        - action: sync+restart
          path: ./services/file
          target: /services/file
    ports:
      - "${FILE_SERVICE_PORT}:${FILE_SERVICE_PORT}"
    expose:
      - ${FILE_SERVICE_PORT}
    networks:
      - entask
    volumes:
      - ./services/file:/services/file
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.file-service.loadbalancer.server.port=${FILE_SERVICE_PORT}"
      - "traefik.http.routers.file.rule=PathRegexp(`/api/file(.*?)`)"
      - "traefik.http.routers.file.service=file-service"
      
  conversion-service:
    container_name: service-conversion
    build:
      context: ./services/conversion
      dockerfile: Dockerfile
    restart: unless-stopped
    environment:
      CONVRESION_SERVICE_VERSION:  ${CONVERSION_SERVICE_VERSION}
      CONVERSION_SERVICE_HOST: ${CONVERSION_SERVICE_HOST}
      CONVERSION_SERVICE_PORT: ${CONVERSION_SERVICE_PORT}
      NATS_USER: ${NATS_USER}
      NATS_PASSWORD: ${NATS_PASSWORD}
      NATS_HOST: ${NATS_HOST}
      NATS_CLIENT_PORT: ${NATS_CLIENT_PORT}
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.conversion-service.loadbalancer.server.port=${CONVERSION_SERVICE_PORT}"
      - "traefik.http.routers.conversion.rule=PathRegexp(`/api/conversion(.*?)`)"
      - "traefik.http.routers.conversion.service=conversion-service"
    ports:
      - "${CONVERSION_SERVICE_PORT}:${CONVERSION_SERVICE_PORT}"
    expose:
      - ${CONVERSION_SERVICE_PORT}
    networks:
      - entask
    volumes:
      - ./services/conversion:/services/conversion
    depends_on:
      - nats-1
      - nats-2
      - nats-3
    develop:
      watch:
        - action: sync+restart
          path: ./services/conversion
          target: /services/conversion
  
  llm-service:
    container_name: service-llm
    build:
      context: ./services/llm
      dockerfile: Dockerfile
    environment:
      LLM_SERVICE_HOST: ${LLM_SERVICE_HOST}
      LLM_SERVICE_PORT: ${LLM_SERVICE_PORT}
      LLM_SERVICE_VERSION: ${LLM_SERVICE_VERSION}
      LLM_SERVICE_MODEL: ${LLM_SERVICE_MODEL}
      LLM_SERVICE_SYSTEM_PROMPT: ${LLM_SERVICE_SYSTEM_PROMPT}
      DOCKER_MODEL_RUNNER_PROTOCOL: ${DOCKER_MODEL_RUNNER_PROTOCOL}
      DOCKER_MODEL_RUNNER_LISTEN: ${DOCKER_MODEL_RUNNER_LISTEN}
    networks:
      - entask
    ports: 
      - "${LLM_SERVICE_PORT}:${LLM_SERVICE_PORT}"
    volumes:
      - "./services/llm:/services/llm"
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.llm-service.loadbalancer.server.port=${LLM_SERVICE_PORT}"
      - "traefik.http.routers.llm.rule=PathRegexp(`/api/llm(.*?)`)"
      - "traefik.http.routers.llm.service=llm-service"
    develop:
      watch:
        - action: sync+restart
          path: ./services/llm
          target: /services/llm
  
  thumbnailer-converter:
    container_name: converter-thumbnailer
    build:
      context: ./converters/thumbnailer
      dockerfile: Dockerfile
    environment:
      THUMBNAILER_CONVERTER_PORT: ${THUMBNAILER_CONVERTER_PORT}
      NATS_USER: ${NATS_USER}
      NATS_PASSWORD: ${NATS_PASSWORD}
      NATS_HOST: ${NATS_HOST}
      NATS_CLIENT_PORT: ${NATS_CLIENT_PORT}
      THUMBNAILER_CONVERTER_VERSION: ${THUMBNAILER_CONVERTER_VERSION}
      WS_PROXY_HOST: ${WS_PROXY_HOST}
      WS_PROXY_PORT: ${WS_PROXY_PORT}
    restart: unless-stopped
    volumes:
      - ./converters/thumbnailer:/converters/thumbnailer
    networks:
      - entask
    depends_on:
      - nats-1
      - nats-2
      - nats-3
      - conversion-service
    develop:
      watch:
        - action: sync+restart
          path: ./converters/thumbnailer
          target: /converters/thumbnailer
          
  waveformer-converter:
    container_name: converter-waveformer
    build:
      context: ./converters/waveformer
      dockerfile: Dockerfile
    environment:
      WAVEFORMER_CONVERTER_PORT: ${WAVEFORMER_CONVERTER_PORT}
      NATS_USER: ${NATS_USER}
      NATS_PASSWORD: ${NATS_PASSWORD}
      NATS_HOST: ${NATS_HOST}
      NATS_CLIENT_PORT: ${NATS_CLIENT_PORT}
      WAVEFORMER_CONVERTER_VERSION: ${WAVEFORMER_CONVERTER_VERSION}
    restart: unless-stopped
    volumes:
      - ./converters/waveformer:/converters/waveformer
    networks:
      - entask
    depends_on:
      - nats-1
      - nats-2
      - nats-3
      - conversion-service
    develop:
      watch:
        - action: sync+restart
          path: ./converters/waveformer
          target: /converters/waveformer
          
  text-recognizer-converter:
    container_name: converter-text-recognizer
    build:
      context: ./converters/text-recognizer
      dockerfile: Dockerfile
    environment:
      TEXT_RECOGNIZER_CONVERTER_PORT: ${TEXT_RECOGNIZER_CONVERTER_PORT}
      NATS_USER: ${NATS_USER}
      NATS_PASSWORD: ${NATS_PASSWORD}
      NATS_HOST: ${NATS_HOST}
      NATS_CLIENT_PORT: ${NATS_CLIENT_PORT}
      TEXT_RECOGNIZER_CONVERTER_VERSION: ${TEXT_RECOGNIZER_CONVERTER_VERSION}
    restart: unless-stopped
    volumes:
      - ./converters/text-recognizer:/converters/text-recognizer
    networks:
      - entask
    depends_on:
      - nats-1
      - nats-2
      - nats-3
      - conversion-service
    develop:
      watch:
        - action: sync+restart
          path: ./converters/text-recognizer
          target: /converters/text-recognizer
          
  term-extractor-converter:
    container_name: converter-term-extractor
    build:
      context: ./converters/term-extractor
      dockerfile: Dockerfile
    environment:
      TERM_EXTRACTOR_CONVERTER_HOST: ${TERM_EXTRACTOR_CONVERTER_HOST}
      TERM_EXTRACTOR_CONVERTER_PORT: ${TERM_EXTRACTOR_CONVERTER_PORT}
      NATS_USER: ${NATS_USER}
      NATS_PASSWORD: ${NATS_PASSWORD}
      NATS_HOST: ${NATS_HOST}
      NATS_CLIENT_PORT: ${NATS_CLIENT_PORT}
      TERM_EXTRACTOR_CONVERTER_VERSION: ${TERM_EXTRACTOR_CONVERTER_VERSION}
    restart: unless-stopped
    volumes:
      - ./converters/term-extractor:/converters/term-extractor
    networks:
      - entask
    depends_on:
      - nats-1
      - nats-2
      - nats-3
      - conversion-service
    develop:
      watch:
        - action: sync+restart
          path: ./converters/text-recognizer
          target: /converters/text-recognizer        
  
  ws-proxy:
    container_name: proxy-websocket
    build:
      context: ./gateway/proxy/ws
      dockerfile: Dockerfile
    environment:
      WS_PROXY_HOST: ${WS_PROXY_HOST}
      WS_PROXY_PORT: ${WS_PROXY_PORT}
    ports:
      - "${WS_PROXY_PORT}:${WS_PROXY_PORT}"
    volumes:
      - ./gateway/proxy/ws:/gateway/proxy/ws
    networks:
      - entask
    labels:
      - "traefik.enable=true"
      - "traefik.http.services.ws-proxy.loadbalancer.server.port=${WS_PROXY_PORT}"
      - "traefik.http.routers.ws-proxy.rule=PathRegexp(`/ws(.*?)`)"
      - "traefik.http.routers.ws-proxy.service=ws-proxy"
    develop:
      watch:
        - action: sync+restart
          path: ./gateway/proxy/ws
          target: /gateway/proxy/ws
          
  frontend:
    container_name: frontend
    build: ./frontend
    ports:
      - "${FRONTEND_PORT}:${FRONTEND_PORT}"
    volumes:
      - ./frontend:/frontend
      - node_modules:/frontend/node_modules:rw
    networks:
      - entask
    develop:
      watch:
        - action: sync+restart
          path: ./frontend
          target: /frontend
          
volumes:
  node_modules: {}
          
networks:
  entask:
    name: entask